Humam Rashid
CISC 7120X, Fall 2019.

=== PART 1 ===

1. The are many different programming languages because of several reasons:
    a. Many languages evolved from older ones as new programming methodologies,
    syntax, types, etc. were developed.
    b. As new paradigms (e.g., functional, logic, constraint, aspect) and
    application domains (e.g., system administration, AI, web-development) were
    discovered, newer languages were designed around their concepts to ease
    software development.
    b. Personal preference also played a significant role from early on as
    designers preferred certain features that were not available in existing
    languages and some were just designed for fun, for education,
    proof-of-concept and so on.

2. Among the things that make programming languages successful are:
    a. Expressiveness: essentially means being able to write desired algorithms,
    etc. in a relatively easy or intuitive manner.
    b. Availability of implementations: some programming languages have official
    implementations while others have standards/definitions which different
    implementations target their compilers or interpreters toward. Availability
    of good, well-supported implementations is often taken as a key indicator of
    a language's reliability in general.
    c. Efficiency: code in the language needs to run fast enough to get work
    done "quickly." What counts as quick enough can and very often does depend
    on the specific implementation and application domain.
    d. Productivity: programming languages allowing for reduced development time
    and developer ease are often chosen over those with steep development or
    learning time, especially in industry.
    e. Industrial support/sponsorship: languages developed directly by or for
    which development is funded by corporations tend to see wide-spread use,
    often starting with internal use by the sponsoring entity.

3. Reasons for studying programming languages include:
    a. Understanding concepts, features and problem-solving techniques at a
    higher-level. For example, different languages often allow for different
    levels of abstraction or certain built-in data types/structures which allow
    for reasoning about problem solutions in a more intuitive way.
    b. Knowing the different methodologies behind different languages or the
    types of application they are particularly strong in allows for the
    developer to choose "the right tool for the job."
    c. Having knowledge of different languages allows for faster learning of new
    languages in general in a similar fashion to natural languages.
    d. Even if one does not switch to a new language for a task, knowing
    different features or techniques used commonly in other languages allow for
    the possibility to use such techniques where applicable without significant
    shifts in production time.

4. It is important to study the implementation of programming languages to:
    a. Understand how languages are specified and implemented. This also helps
    in learning about different paradigms and their approaches in software
    methodology. Another benefit is that many of the techniques used in design
    and implementation have uses in other areas of computer science research and
    practical software development.
    b. Understanding obscure phenomena. Studying implementation details allows
    us to better prepare and work out problems when unexpected or obscure issues
    show up during development.
    c. Studying language design and implementation allows us to better develop
    or follow well-tested methodologies, style conventions and utilize
    techniques that make programs in the specific language (or other ones) more
    efficient.
    d. Studying design and implementation of programming languages is also the
    primary means of knowing how to design and implement your own language.
    While most people do not need to do this for general-purpose programming, it
    is more often useful in domain-specific tasks.

5. Two languages per paradigm:
    a. Procedural: ALGOL 60, C.
    b. Object-Oriented: Smalltalk, Ruby.
    c. Logic: Prolog, Picat.
    d. Functional: Common Lisp, Standard ML.

6. Features common to object-oriented programming languages include:
    a. Abstract data types.
    b. Inheritance and overriding mechanisms.
    c. Polymorphism.
    d. Dynamic binding.

7. Features common to functional programming languages include:
    a. Single assignment variables and no side-effects (at least in pure
    functional languages).
    b. Recursion (instead of iteration).
    c. Rule-based function definitions and pattern matching.
    d. Higher-order functions.
    e. Lazy evaluation.
    f. Meta-programming.

8. Features common to logic programming languages include:
    a. Logic variables.
    b. Recursion (instead of iteration).
    c. Unification.
    d. Backtracking and non-determinism.
    e. Meta-programming.

=== PART 2 ===

1. Ruby implementation of Trabb Pardo-Knuth algorithm:

S = []
puts("Enter 11 numbers: ")
11.times { S.push(gets.to_f) }
puts("Result: ")
S.reverse.each do |e|
  val = ->(x) { Math.sqrt(x.abs) + (5 * x) }.call(e)
  puts (val > 500) ? "f(#{e}): caused overflow!" : "f(#{e}) = #{val}"
end

2. ANSI C implementation of Trabb Pardo-Knuth algorithm:

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
double func(double n) {
    return sqrt(fabs(n)) + (5.0 * n);
}
int main(void)
{
    int e;
    double S[11];
    printf("Enter 11 numbers:\n");
    for (e = 0; e < 11; e++)
        scanf("%lf", &S[e]);
    printf("Result:\n");
    for (e = 10; e >= 0; e--) {
        double val = func(S[e]);
        (val > 500.0)
            ? printf("f(%f) = %s\n", S[e], "caused overflow!")
            : printf("f(%f) = %f\n", S[e], val);
    }
    return EXIT_SUCCESS;
}

=== PART 3 ===

=== PART 4 ===

# EOF.
